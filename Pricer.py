"""
Pricer.py
Andrew Ortego
12/27/2017

Description:
Solves the Order Book Programming Problem. Reads an input-file containing one command per line. Each command will run an
Add or Remove order. When the size of an order matches or exceeds the given target size, output is printed to the
console reporting the best buy or sell price available. When a Remove order is executed, output is printed if the size
of an order had previously met the target size.

Usage:
python Pricer.py <target size integer>

Pricer will look for a file called pricer.in to retrieve input commands.
"""

import os
import sqlite3
import sys


class Order:
    def __init__(self, timestamp, type_literal, order_id, size, price=0.0, side="."):
        """
        :param timestamp: The time when this message was generated by the market, as milliseconds since midnight.
        :param type_literal: Denotes an Add or a Reduce order with an "A" or an "R".
        :param order-id: The unique string that identifies the order.
        :param size: The size in shares of this order, when it was initially sent to the market by some stock
                     trader.
        :param price: The limit price of this order.
        :param side: A 'B' if this is a buy order (a bid), or a 'S' if this is a sell order (an ask).
        """
        self.timestamp = int(timestamp)
        self.type_literal = type_literal
        self.order_id = order_id
        self.size = int(size)
        self.price = float(price)
        self.side = side

    def add_order_to_book(self):
        """
        Update the book by adding a new order.
        """
        data = (self.timestamp, self.type_literal, self.order_id, self.size, self.price, self.side)
        db.execute('INSERT INTO orders VALUES(?, ?, ?, ?, ?, ?)', data)
        db_con.commit()

    def reduce_order(self):
        """
        Update a preexisting order with a Reduce command. Delete the
        """
        db.execute('SELECT * FROM orders WHERE orderId=? ORDER BY timestamp DESC', (self.order_id,))
        preexisting_order = db.fetchall()[0]
        reduced_size = preexisting_order[3] - self.size
        if reduced_size <= 0:
            db.execute('DELETE FROM orders WHERE orderId=?', (self.order_id,))
            db_con.commit()
        elif reduced_size > 0:
            db.execute('UPDATE orders SET size=? WHERE orderId=?', (reduced_size, self.order_id))
            db_con.commit()
        else:
            pass  # placeholder for future error checking


class Book:
    def __init__(self, target_size):
        """
        Creates the book which will keep track of all available shares and current buy/sell prices.
        """
        self.ask_size = 0
        self.bid_size = 0
        self.input_data = self.get_input_data()
        self.target_size = self.get_target_size(target_size)

    def calculate_price(self, order):
        """
        Calculate the best possible bid or ask price and print relevant information.
        :param order: The order which triggered a new update to the book.
        :return: Float value which represents the current buy/sell price.
        """
        if order.side == 'B':
            db.execute('SELECT * FROM orders WHERE side=? ORDER BY price DESC, size DESC', (order.side,))
        elif order.side == 'S':
            db.execute('SELECT * FROM orders WHERE side=? ORDER BY price ASC, size DESC', (order.side,))
        order_data = db.fetchall()
        total_shares = 0
        price = 0.00
        for share in order_data:  # ToDo make this a recursive function
            if total_shares == self.target_size:
                return price
            elif total_shares < self.target_size:
                if total_shares + share[3] >= self.target_size:
                    price += (self.target_size - total_shares) * share[4]
                    total_shares += self.target_size - total_shares
                    return price
                else:
                    total_shares += share[3]
                    price += share[3] * share[4]
            elif total_shares > self.target_size:
                print("ERROR: Number of shares exceeds target size, price is incorrect")
                return price

    @staticmethod
    def get_input_data():
        """
        Attempt to open the file and parse the input, then remove any newline characters at the end of a line.
        Assume the format of the data is correct/expected and that no error/consistency checking is required.
        """
        input_file_path = os.path.join(os.getcwd(), 'pricer.in')
        try:
            with open(input_file_path) as file_data:
                input_data = file_data.readlines()
        except FileNotFoundError:
            print('File not found: {0}\nPut the pricer.in file in this script\'s directory.'.format(input_file_path))
            sys.exit('Exiting program...')
        else:
            return [line.strip() for line in input_data]

    @staticmethod
    def get_target_size(target_size):
        """
        Cast the given target_size to an integer
        """
        try:
            return int(target_size)
        except ValueError:
            print('Incorrect argument provided for target-size. Please specify an integer. (e.g. 200)')
            sys.exit('Exiting program...')

    def process_command(self, line):
        """
        Parse the command, create a new order and add it to the book.
        :param line: a single space-delineated command from the input file.
        """
        commands = line.split(' ')
        if self.verify_input(commands):
            if len(commands) == 6:  # Switch the side and size parameters before instantiating a new order
                commands[3], commands[5] = commands[5], commands[3]
            order = Order(*commands)
            self.update_book(order)
        else:
            print(" Skipping current command.")

    def update_book(self, order):
        """
        Add an order to the book unless it's a reduce order in which case reduce the size of an existing order. Update
        the current bid or ask size accordingly. If the update requires output, print the relevant message.
        :param order: the order being used the calculate total bid/ask size.
        """
        if order.type_literal == 'R':
            db.execute('SELECT * FROM orders WHERE orderId=?', (order.order_id,))
            preexisting_order_data = db.fetchall()[0]  # Only one result is expected from the query
            preexisting_order = Order(*list(preexisting_order_data))
            order.reduce_order()
            if preexisting_order.side == 'B':
                if self.bid_size - order.size >= self.target_size:
                    price = self.calculate_price(preexisting_order)
                    print("{0} S {1:.2f}".format(order.timestamp, price))
                elif self.bid_size >= self.target_size:
                    print('{0} S NA'.format(order.timestamp))
                self.bid_size -= order.size
            elif preexisting_order.side == 'S':
                if self.ask_size - order.size >= self.target_size:
                    price = self.calculate_price(preexisting_order)
                    print('{0} B {1:.2f}'.format(order.timestamp, price))
                elif self.ask_size >= self.target_size:
                    print('{0} B NA'.format(order.timestamp))
                self.ask_size -= order.size

        elif order.type_literal == 'A':
            if order.side == 'B':
                self.bid_size += order.size
                order.add_order_to_book()
                if self.bid_size >= self.target_size:
                    price = self.calculate_price(order)
                    print("{0} S {1:.2f}".format(order.timestamp, price))
            elif order.side == 'S':
                self.ask_size += order.size
                order.add_order_to_book()
                if self.ask_size >= self.target_size:
                    price = self.calculate_price(order)
                    print("{0} B {1:.2f}".format(order.timestamp, price))

    @staticmethod
    def verify_input(commands):
        """
        Check validity of a given command. Print an error message to the console if an error is found.
        :return: None if an issue is found. Otherwise return the original list of commands
        """
        # Check number of commands, should either be 4 (Reduce) or 6 (Add)
        if len(commands) is 4:
            # Check timestamp
            pass

            # Check literal
            if commands[1] != "R":
                print("Invalid input detected; unrecognized literal: {0}. Please provide an R.".format(commands[1]),
                      end="")
                return None

            # Check order id
            db.execute('SELECT * FROM orders WHERE orderId=? ORDER BY timestamp DESC', (commands[2],))
            data = db.fetchall()
            if len(data) == 0:
                print("No record found with orderId: {0}. Reduce cannot be performed.".format(commands[2]),
                      end="")
                return None
            elif len(data) > 1:
                print("Multiple records found with orderId: {0}. Reduce should only target one unique order.".format(
                    commands[2]), end="")
                return None

            # Check size type
            try:
                int(commands[3])
            except ValueError:
                print("Invalid input detected; non-integer value provided for size: {0}.".format(commands[3]), end="")
                return None

            # Check size value
            if int(commands[3]) < 0:
                print("Invalid input detected; negative integer provided for size: {0}.".format(commands[3]), end="")
                return None

            # All checks passed
            return commands

        elif len(commands) is 6:
            # Check timestamp
            pass

            # Check literal
            if commands[1] != "A":
                print("Invalid input detected; unrecognized literal: {0}.".format(commands[1]), end="")
                return None

            # Check order id
            db.execute('SELECT * FROM orders WHERE orderId=? ORDER BY timestamp DESC', (commands[2],))
            data = db.fetchall()
            if len(data) > 0:
                print("Record with orderId {0} already exists. Cannot insert a new record with duplicate Id.".format(
                    commands[2]), end="")
                return None

            # Check side
            if commands[3] not in ["B", "S"]:
                print("Invalid input detected; unrecognized side: {0}. Please provide a B or S.".format(commands[3]),
                      end="")
                return None

            # Check price
            try:
                float(commands[4])
            except ValueError:
                print("Invalid price detected; non-float value provided for price: {0}.".format(commands[4]), end="")
                return None

            # Check size type
            try:
                int(commands[5])
            except ValueError:
                print("Invalid input detected; non-integer value provided for size: {0}.".format(commands[5]), end="")
                return None

            # Check size value
            if int(commands[5]) < 0:
                print("Invalid input detected; negative integer provided for size: {0}.".format(commands[5]), end="")
                return None

            # All checks passed
            return commands

        else:
            print("Unexpected number of commands provided: {0}.".format(len(commands)), end="")
            return None


def initialize_database():
    """
    Prepare a database prior to processing input. This function will delete an on-disk database file if found, so if you
    want to keep previous databases, relocate or rename it before running this script.
    """
    global db
    global db_con
    # db_con = sqlite3.connect('book.db')  # Use to create a database on disk
    db_con = sqlite3.connect(':memory:')  # Use for performance boost but no database on disk
    db = db_con.cursor()
    try:
        db.execute('DROP TABLE orders')
        db_con.commit()
    except sqlite3.OperationalError:
        pass
    finally:
        db.execute('''CREATE TABLE orders
                   (timestamp INTEGER, type TEXT, orderId TEXT, size INTEGER, price REAL, side TEXT)''')
        db_con.commit()


def main():
    """
    Create a new book to open the input file, parse input from the file, then begin processing input line-by-line.
    """
    initialize_database()
    book = Book(sys.argv[1])
    for line in book.input_data:
        book.process_command(line)

if __name__ == '__main__':
    main()
